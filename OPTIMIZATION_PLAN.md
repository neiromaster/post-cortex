# План за Оптимизация и Архитектурни Подобрения на Post-Cortex

Този документ описва критичните области за подобрение в системата Post-Cortex, идентифицирани на база анализ на текущия код в `dev` бранча. Целта е повишаване на стабилността, скалируемостта и производителността.

## 1. Оптимизация на RocksDB (Критично)
**Проблем:** `RealRocksDBStorage` извършва блокиращи I/O операции директно в `async` методи, което може да блокира `tokio` runtime нишките.

**Инструкции за имплементация:**
1.  Във файла `src/storage/rocksdb_storage.rs`, модифицирайте всички методи, които взаимодействат с базата данни (`get`, `put`, `delete`, `iterator`).
2.  Обвийте блокиращите извиквания в `tokio::task::spawn_blocking`.
3.  Примерна промяна за `load_session`:
    ```rust
    pub async fn load_session(&self, session_id: Uuid) -> Result<ActiveSession> {
        let db = self.db.clone();
        let key = format!("session:{}", session_id);
        
        tokio::task::spawn_blocking(move || {
            match db.get(key.as_bytes())? {
                Some(data) => { /* логика за десериализация */ },
                None => Err(anyhow::anyhow!("Session not found"))
            }
        }).await?
    }
    ```

## 2. Скалируемост на Векторната База Данни
**Проблем:** `LockFreeVectorDB` съхранява всички вектори и HNSW индекса в RAM паметта (`Arc<DashMap>`), което ограничава мащабируемостта.

**Инструкции за имплементация:**
1.  **Краткосрочно:** Имплементирайте "Product Quantization" (PQ) или бинарно квантуване за намаляване на размера на векторите в паметта (намаление до 32x).
2.  **Дългосрочно:** Интегрирайте специализирано решение, работещо върху диск:
    * Разгледайте миграция към **LanceDB** (embedded, native Rust, disk-based).
    * Алтернативно, използвайте **Qdrant** като външна услуга, ако архитектурата позволява.
3.  Премахнете ръчното изграждане на HNSW графа в паметта при стартиране на демона.

## 3. Подобрено Извличане на Същности (Entity Extraction)
**Проблем:** Методът `extract_entities_from_text` разчита на RegEx, което води до много фалшиви позитиви и пропуснати връзки.

**Инструкции за имплементация:**
1.  В `src/session/active_session.rs`, заменете или допълнете RegEx логиката с NLP модел.
2.  Използвайте `candle` (вече е dependency) за зареждане на малък BERT-based модел за **Named Entity Recognition (NER)**.
3.  Търсете модели, оптимизирани за технически текст (напр. обучени върху StackOverflow или техническа документация), за да разпознавате правилно термини като "Rust", "API", "Mutex".

## 4. Управление на Конкурентността
**Проблем:** Използването на `ArcSwap` за цялата структура `ActiveSession` води до "write amplification" – цялата сесия се клонира при всяка малка промяна.

**Инструкции за имплементация:**
1.  Рефакторирайте `ActiveSession` в `src/session/active_session.rs`.
2.  Разделете монолитната структура на по-малки компоненти с индивидуално заключване:
    * `entity_graph`: Използвайте собствен `DashMap` или `RwLock`.
    * `hot_context`: Използвайте `RwLock<VecDeque>`.
3.  Избягвайте `ArcSwap` за структури, които се променят често и са големи по размер. Запазете го само за малки конфигурационни обекти или метаданни.

## 5. Обработка на Грешки (Error Handling)
**Проблем:** Масово използване на `anyhow::Result` и string errors затруднява програмното обработване на специфични грешки.

**Инструкции за имплементация:**
1.  Създайте нов модул `src/core/error.rs`.
2.  Дефинирайте enum `SystemError` използвайки макроса `thiserror`:
    ```rust
    #[derive(thiserror::Error, Debug)]
    pub enum SystemError {
        #[error("Database IO error: {0}")]
        DbError(#[from] rocksdb::Error),
        #[error("Session {0} not found")]
        SessionNotFound(Uuid),
        #[error("Serialization error: {0}")]
        SerializationError(#[from] bincode::Error),
        // други грешки...
    }
    ```
3.  Заменете връщаните типове в публичните методи да използват тази типизирана грешка.

## 6. Тестове и CI/CD
**Проблем:** Интеграционните тестове отварят реални TCP портове, което води до нестабилност (flaky tests).

**Инструкции за имплементация:**
1.  В `tests/integration_daemon.rs`, пренапишете тестовете да използват `tower::service_fn` или `axum::test_helpers`. Това позволява тестване на HTTP логиката директно, без мрежов слой.
2.  Добавете **Property-based testing** (чрез `proptest`) за `LockFreeVectorDB`, за да верифицирате коректността на конкурентните операции при различни сценарии на натоварване.
